using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerator
{
    [Generator]
    public class Generator : ISourceGenerator
    {
        private static readonly SymbolDisplayFormat _symbolDisplayFormat = new(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);

        private const string CompiledReflectionStub = @"
using System.Collections.Generic;
using System.Linq;

// <auto-generated />
public class CompiledReflection
{

    public static IEnumerable<string> GetPropertyNames<T>() => Enumerable.Empty<string>();
    public static IEnumerable<CompiledPropertyInfo> GetPropertyInfo<T>() => Enumerable.Empty<CompiledPropertyInfo>();
}
";
        private const string CompiledPropertyInfoStub = @"
using System;

// <auto-generated />
public class CompiledPropertyInfo
{
    public string Name { get; }
    public string TypeName { get; }

    public CompiledPropertyInfo(string name, string typeName)
    {
        Name = name;
        TypeName = typeName;
    }

    public object GetValue(object instance) => null;
}";

        private const string CompiledReflectionBase = @"
using System.Collections.Generic;
using System.Linq;

// <auto-generated />
public partial class CompiledReflection
{
    public static partial IEnumerable<string> GetPropertyNames<T>();
    public static partial IEnumerable<CompiledPropertyInfo> GetPropertyInfo<T>();
}
";
        private const string CompiledPropertyInfoBase = @"
using System;

// <auto-generated />
public partial class CompiledPropertyInfo
{
    public string Name { get; }
    public string TypeName { get; }

    public CompiledPropertyInfo(string name, string typeName)
    {
        Name = name;
        TypeName = typeName;
    }

    public partial object GetValue(object instance);
}";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new CompiledReflectionSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            //System.Diagnostics.Debugger.Launch();

            if (context.SyntaxReceiver is not CompiledReflectionSyntaxReceiver receiver)
            {
                return;
            }

            if (!receiver.ExpressionsUsingCompiledReflection.Any())
            {
                context.AddSource("CompiledReflection.cs", CompiledPropertyInfoStub);
                context.AddSource("CompiledReflection.cs", CompiledReflectionStub);
                return;
            }

            context.AddSource("CompiledPropertyInfoBase.cs", SourceText.From(CompiledPropertyInfoBase, Encoding.UTF8));
            context.AddSource("CompiledReflectionBase.cs", SourceText.From(CompiledReflectionBase, Encoding.UTF8));
            
            var options = (context.Compilation as CSharpCompilation).SyntaxTrees[0].Options as CSharpParseOptions;
            var compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(CompiledReflectionBase, Encoding.UTF8), options))
                                                    .AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(CompiledPropertyInfoBase, Encoding.UTF8), options));

            var sb = new StringBuilder();

            sb.AppendLine();

            var getPropertyNamesCalls = new HashSet<ITypeSymbol>();
            var getPropertyInfoCalls = new HashSet<ITypeSymbol>();

            foreach (var compiledReflectionExpression in receiver.ExpressionsUsingCompiledReflection)
            {
                var model = compilation.GetSemanticModel(compiledReflectionExpression.SyntaxTree);
                var methodSymbol = model.GetSymbolInfo(compiledReflectionExpression.Expression).Symbol as IMethodSymbol;

                if (methodSymbol == null)
                {
                    continue;
                }

                var typeArgument = methodSymbol.TypeArguments.First();

                if (methodSymbol.Name.Contains("GetPropertyNames"))
                {
                    if (!getPropertyNamesCalls.Contains(typeArgument))
                    {
                        getPropertyNamesCalls.Add(typeArgument);
                    }
                }
                else if (methodSymbol.Name.Contains("GetPropertyInfo"))
                {
                    if (!getPropertyInfoCalls.Contains(typeArgument))
                    {
                        getPropertyInfoCalls.Add(typeArgument);
                    }
                }
            }

            CreatePropertyInfoMethods(sb, getPropertyInfoCalls);
            string compiledPropertyInfoClass = sb.ToString();
            //System.IO.File.WriteAllText($@"D:\Code\Tests\SourceGenerators\CompiledReflection\SourceGenerator\GeneratedFiles\io\CompiledReflection{DateTime.Now.Ticks}.cs", compiledReflectionClass);
            context.AddSource("CompiledPropertyInfo.cs", compiledPropertyInfoClass);

            sb = new StringBuilder();

            sb.Append(@"
using System.Collections.Generic;
using System.Linq;

// <auto-generated />
public class TypeWrapper<T>
{

}

// <auto-generated />
public partial class CompiledReflection
{"
);

            CreateGetPropertyNames(sb, getPropertyNamesCalls);
            sb.AppendLine();
            CreateGetPropertyInfo(sb, getPropertyInfoCalls);


            sb.AppendLine();
            sb.AppendLine("}");

            string compiledReflectionClass = sb.ToString();
            //System.IO.File.WriteAllText($@"D:\Code\Tests\SourceGenerators\CompiledReflection\SourceGenerator\GeneratedFiles\io\CompiledPropertyInfo{DateTime.Now.Ticks}.cs", compiledPropertyInfoClass);
            context.AddSource("CompiledReflection.cs", compiledReflectionClass);
        }

        private void CreateGetPropertyInfo(StringBuilder sb, HashSet<ITypeSymbol> getPropertyInfoCalls)
        {
            sb.Append(@"
    public static partial IEnumerable<CompiledPropertyInfo> GetPropertyInfo<T>()
    {
        var wrapper = new TypeWrapper<T>();

        return wrapper switch
        {"
            );

            foreach (var type in getPropertyInfoCalls)
            {
                var typeName = type.ToDisplayString(_symbolDisplayFormat);
                sb.AppendLine($"\t\t\tTypeWrapper<{typeName}> w => GetPropertyInfo(w),");
            }

            sb.Append(@"
            _ => throw new System.NotImplementedException()
            };
        }"
            );

            foreach (var type in getPropertyInfoCalls)
            {
                var typeName = type.ToDisplayString(_symbolDisplayFormat);

                var properties = type.GetMembers().Where(s => s.Kind == SymbolKind.Property && !s.IsStatic).OfType<IPropertySymbol>().ToArray();
                var propertyNames = type.GetMembers().Where(s => s.Kind == SymbolKind.Property && !s.IsStatic).Select(s => s.Name).ToArray();

                sb.AppendLine(@$"
    private static IEnumerable<CompiledPropertyInfo> GetPropertyInfo(TypeWrapper<{typeName}> wrapper)
    {{
        return new List<CompiledPropertyInfo>
        {{"
                );

                foreach (var property in properties)
                {
                    sb.AppendLine($"\t\t\tnew CompiledPropertyInfo(\"{property.Name}\", \"{property.Type.ToDisplayString(_symbolDisplayFormat)}\"),");
                }

                sb.AppendLine("\t\t};}");
            }
        }

        private void CreatePropertyInfoMethods(StringBuilder sb, HashSet<ITypeSymbol> getPropertyInfoCalls)
        {
            sb.Append(@"
using System.Collections.Generic;
using System.Linq;

// <auto-generated />
public partial class CompiledPropertyInfo
{"
);

            sb.Append(@"
    public partial object GetValue(object instance)
    {
        return instance switch
        {"
            );

            foreach (var type in getPropertyInfoCalls)
            {
                var typeName = type.ToDisplayString(_symbolDisplayFormat);
                sb.AppendLine($"\t\t\t{typeName} i => GetValue(i),");
            }

            sb.Append(@"
            _ => throw new System.NotImplementedException()
            };
        }"
            );

            foreach (var type in getPropertyInfoCalls)
            {
                var typeName = type.ToDisplayString(_symbolDisplayFormat);
                var propertyNames = type.GetMembers().Where(s => s.Kind == SymbolKind.Property && !s.IsStatic).Select(s => s.Name).ToArray();

                sb.AppendLine(@$"
    private object GetValue({typeName} instance)
    {{
        return Name switch
        {{"
                );

                foreach (string propertyName in propertyNames)
                {
                    sb.AppendLine($"\t\t\t\"{propertyName}\" => instance.{propertyName},");
                }

                sb.AppendLine("\t\t};}");
            }

            sb.AppendLine("}");
        }

        private void CreateGetPropertyNames(StringBuilder sb, HashSet<ITypeSymbol> typesWhereGetPropertyNamesWasCalled)
        {
            sb.Append(@"
    public static partial IEnumerable<string> GetPropertyNames<T>()
    {
        var wrapper = new TypeWrapper<T>();

        return wrapper switch
        {"
            );

            foreach (var type in typesWhereGetPropertyNamesWasCalled)
            {
                var typeName = type.ToDisplayString(_symbolDisplayFormat);
                sb.AppendLine($"\t\t\tTypeWrapper<{typeName}> w => GetPropertyNames(w),");
            }

            sb.Append(@"
            _ => throw new System.NotImplementedException()
            };
        }"
            );

            foreach (var type in typesWhereGetPropertyNamesWasCalled)
            {
                var typeName = type.ToDisplayString(_symbolDisplayFormat);

                var propertyNames = type.GetMembers().Where(s => s.Kind == SymbolKind.Property && !s.IsStatic).Select(s => s.Name).ToArray();

                sb.AppendLine(@$"
    private static IEnumerable<string> GetPropertyNames(TypeWrapper<{typeName}> wrapper)
    {{
        return new List<string>
        {{"
                );

                foreach (string propertyName in propertyNames)
                {
                    sb.AppendLine("\t\t\t\"" + propertyName + "\",");
                }

                sb.AppendLine("\t\t};}");
            }
        }
    }

    public class A
    {
        public string Ab { get; set; }
        public int B { get; set; }
    }

    public class B
    {
        public int MyProperty { get; set; }
        public string MyProperty2 { get; set; }
    }


    public partial class CompiledPropertyInfo
    {
        public CompiledPropertyInfo(string name, string typeName)
        {
            Name = name;
            TypeName = typeName;
        }

        public string Name { get; set; }
        public string TypeName { get; set; }

        public partial object GetValue(object instance);

        public partial object GetValue(object instance)
        {
            return instance switch
            {
                A i => GetValue(i),
                B i => GetValue(i),
                _ => null
            };
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public object GetValue(A instance)
        {
            return Name switch
            {
                "Ab" => instance.Ab,
                "B" => instance.B,
                _ => throw new NotSupportedException()
            };
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public object GetValue(B instance)
        {
            return Name switch
            {
                "MyProperty" => instance.MyProperty,
                "MyProperty2" => instance.MyProperty2,
                _ => throw new NotSupportedException()
            };
        }
    }

    public partial class CompiledReflection
    {
        private static Dictionary<string, Dictionary<string, object>> _registeredTypes = new Dictionary<string, Dictionary<string, object>>();

        public static IReadOnlyDictionary<string, object> GetProperties<T>()
        {
            _registeredTypes.TryGetValue(typeof(T).FullName, out var result);

            return result ?? new Dictionary<string, object>();
        }

        public static partial IEnumerable<string> GetPropertyNames<T>();

        public static partial IEnumerable<string> GetPropertyNames<T>()
        {
            var wrapper = new TypeWrapper<T>();

            return wrapper switch
            {
                TypeWrapper<A> w => GetPropertyNames(w),
                TypeWrapper<B> w => GetPropertyNames(w),
                _ => throw new System.NotImplementedException()
            };
        }

        public static IEnumerable<CompiledPropertyInfo> GetPropertyInfo<T>()
        {
            var wrapper = new TypeWrapper<T>();

            return wrapper switch
            {
                TypeWrapper<A> w => GetPropertyInfo(w),
                TypeWrapper<B> w => GetPropertyInfo(w),
                _ => throw new System.NotImplementedException()
            };
        }

        private static IEnumerable<CompiledPropertyInfo> GetPropertyInfo(TypeWrapper<A> wrapper)
        {
            return new List<CompiledPropertyInfo>
            {
                new CompiledPropertyInfo("Ab", typeof(string).FullName),
                new CompiledPropertyInfo("B", typeof(int).FullName),
            };
        }

        private static IEnumerable<CompiledPropertyInfo> GetPropertyInfo(TypeWrapper<B> wrapper)
        {
            return new List<CompiledPropertyInfo>
            {

            };
        }

        private static IEnumerable<string> GetPropertyNames(TypeWrapper<A> wrapper)
        {
            return new List<string>
            {
                ""
            };
        }

        private static IEnumerable<string> GetPropertyNames(TypeWrapper<B> wrapper)
        {
            return null;
        }
    }

    public class TypeWrapper<T>
    {

    }
}
